taicol <- fread("www/data/processed/TaiCOL_taxon_20240621_taxaSubGroup.csv",
sep = ",", colClasses = "character", encoding = "UTF-8", na.strings = c("", "NA", "N/A"))
# load the 5km grid file
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp")
grid5km_sf
table(grid5km_sf$landType)
table(grid5km_sf$landType) %>% sum()
# load the 5km grid file
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp") %>%
select(id, center_x, center_y, geometry, landType)
grid5km_sf
# load the tbia table
df_map <- tbia[, c("id", "longitude", "latitude", "coordinatePrecision", "coordinateUncertaintyInMeters", "taxaSubGroup")] %>%
mutate(longitude = as.numeric(longitude), latitude = as.numeric(latitude),
coordinatePrecision = as.numeric(coordinatePrecision),
coordinateUncertaintyInMeters = as.numeric(coordinateUncertaintyInMeters))
rm(tbia, taicol)
df_map <- df_map[df_map$coordinateUncertaintyInMeters < 5000 | is.na(df_map$coordinateUncertaintyInMeters)] # exclude < 5km (5000 meter) for 5km grid plotting, 1,180,542 excluded
20875777-19695235
df_map_stats <- df_map %>%
group_by(taxaSubGroup, latitude, longitude) %>%
count()
# separate to group for parallel processing
n <- 200000
num_groups <- ceiling(nrow(df_map_stats) / n)
records_in_last_group <- nrow(df_map_stats) %% n
group_var <- rep(1:num_groups, each = n)
group_var <- c(group_var, rep(num_groups + 1, times = records_in_last_group))
df_map_stats_groupList <- split(df_map_stats, group_var)
catchLocation <- function(x){
x %>%
st_as_sf(coords = c("longitude", "latitude"), remove = FALSE) %>% # set coordinates
st_set_crs(4326) %>%  # table transform to polygon
st_join(., dg_grid, join = st_intersects, left = TRUE, largest = TRUE) %>%
st_drop_geometry(.)
}
#### parallel ####
cpu.cores <- detectCores() - 8
cl <- makeCluster(cpu.cores)
clusterEvalQ(cl, { # make sure all clusters are ready
library(tidyverse)
library(data.table)
library(sf)
library(lwgeom)
dg_grid <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp")
dg_grid <- as(dg_grid, "sf")%>%
st_set_crs(4326)
sf_use_s2(F)
}
)
system.time(
df_map_grid <- parLapply(cl, df_map_stats_groupList, catchLocation)%>%
do.call(rbind,.)
)
stopCluster(cl)
### 3 make all records table
allOccCount_grid_table <- df_map_grid %>%
group_by(taxaSubGroup) %>%
summarise(allOccCount = sum(n))
fwrite(allOccCount_grid_table, "www/data/processed/df_spatial_allOccCount_grid_table.csv",
row.names = F, quote = T)
allOccCount_grid_table
### 4 make All records shp
allOccCount <- df_map_grid %>%
group_by(id) %>%
summarise(occCount = sum(n))
allOccCount
### 4.1 combine grid counts with 5km geometry
allOccCount_grid <- merge(allOccCount, grid5km_sf, by = "id", all.x = TRUE)
st_write(allOccCount_grid, "www/data/processed/df_map.shp", append = FALSE)
### 5 make taxaSubGroup map
taxaOccCount <- df_map_grid %>%
group_by(taxaSubGroup, id) %>%
summarise(occCount = sum(n))
taxaOccCount
### 5.1 combine grid counts with 5km geometry
taxaOccCount_grid <- merge(taxaOccCount, grid5km_sf, by = "id", all.x = TRUE)
taxaOccCount_grid
names(taxaOccCount_grid) <- c("id", "tSG", "occCount", "geometry") # rename because ESRI cannot save long field name
st_write(taxaOccCount_grid, "www/data/processed/df_taxa_map.shp", append = FALSE)
taxaOccCount_grid
### 5.1 combine grid counts with 5km geometry
taxaOccCount_grid <- merge(taxaOccCount, grid5km_sf, by = "id", all.x = TRUE)
names(taxaOccCount_grid) <- c("id", "tSG", "occCount", "center_x", "center_y", "landType", "geometry") # rename because ESRI cannot save long field name
taxaOccCount_grid
st_write(taxaOccCount_grid, "www/data/processed/df_taxa_map.shp", append = FALSE)
shiny::runApp()
# determine gap level & save as shp file
df_gapCount <- st_read("www/data/processed/df_map.shp")
summary(df_gapCount$occCount)
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp")
number_of_grids_5km <- nrow(grid5km_sf)
sum(df_gapCount$occCount) / number_of_grids_5km # 4653.9
df_gapCount$occCount
sum(df_gapCount$occCount)
df_gapCount
nrow(grid5km_sf)
sum(df_gapCount$occCount) / number_of_grids_5km # 4653.9
df_gapCount <- st_read("www/data/processed/df_map.shp")
summary(df_gapCount$occCount)
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp")
number_of_grids_5km <- nrow(grid5km_sf)
sum(df_gapCount$occCount) / number_of_grids_5km # 3392.8
## use 3,000 as average for gap level
## i.e. each grid has to contain at least 3,000 records to be considered as non-priority
df_gapCount <- df_gapCount %>%
mutate(priority = case_when(occCount < 1000 ~ "建議優先填補",
occCount >= 1000 & occCount < 3000 ~ "建議填補",
occCount >= 3000 ~ "資料筆數高於平均值"))
st_write(df_gapCount, "www/data/processed/df_gapCount_table.shp",
row.names = F, quote = T, append = FALSE)
# save as table
df_gapCount_table <- as.data.frame(df_gapCount) %>%
group_by(priority) %>%
summarise(totalOccCount = sum(occCount))
fwrite(df_gapCount_table, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
df_gapCount_table
df_gapCount
table(df_gapCount$priority)
table(df_gapCount$priority) %>% sum()
df_gapCount
tail(df_gapCount)
nrow(grid5km_sf)
df_gapCount
summary(df_gapCount$occCount)
## because df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- merge(grid5km_sf, df_gapCount, by = "id", all.x = TRUE)
df_gapCount
f
grid5km_sf
## because df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- merge(grid5km_sf, df_gapCount, by = "id", all.x = TRUE)
# determine gap level & save as shp file
df_gapCount <- st_read("www/data/processed/df_map.shp")
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- merge(grid5km_sf, df_gapCount, by = "id", all.x = TRUE)
df_gapCount
df_gapCount_with0 <- grid5km_sf %>%
left_join(df_gapCount, by = "id")
df_gapCount_with0 <- grid5km_sf %>%
st_join(df_gapCount, by = "id")
df_gapCount_with0
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- merge(df_gapCount, grid5km_sf, by = "id", all.y = TRUE)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(grid5km_sf, df_gapCount, by = "id")
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- st_join(grid5km_sf, df_gapCount, by = "id", left = TRUE)
df_gapCount
grid5km_sf
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- st_join(grid5km_sf, df_gapCount, left = TRUE)
df_gapCount_with0
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- st_join(grid5km_sf, df_gapCount, by = "id")
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- st_join(grid5km_sf, df_gapCount, by = "id", all.x = TRUE)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- st_join(grid5km_sf, df_gapCount, left = TRUE)
df_gapCount_with0
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- merge(as.data.frame(df_gapCount), as.data.frame(grid5km_sf_df), by = "id", all.y = TRUE)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- merge(as.data.frame(df_gapCount), as.data.frame(grid5km_sf_df), by = "id")
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- merge(as.data.frame(df_gapCount), as.data.frame(grid5km_sf), by = "id")
df_gapCount_with0
dim(df_gapCount_with0)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- merge(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id")
df_gapCount_with0
dim(df_gapCount_with0)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id")
df_gapCount_with0
dim(as.data.frame(df_gapCount_with0)
)
names(df_gapCount_with0)
df_gapCount
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- grid5km_sf %>%
left_join(df_gapCount %>% select(-all_of(common_cols)), by = "id")
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
common_cols <- intersect(names(grid5km_sf), names(df_gapCount))
common_cols
common_cols <- setdiff(common_cols, "id")
common_cols
df_gapCount_with0 <- grid5km_sf %>%
left_join(df_gapCount %>% select(-all_of(common_cols)), by = "id")
df_gapCount_with0 <- as.data.frame(grid5km_sf) %>%
left_join(as.data.frame(df_gapCount) %>% select(-all_of(common_cols)), by = "id")
df_gapCount_with0
df_gapCount_with0 <- as.data.frame(grid5km_sf) %>%
left_join(as.data.frame(df_gapCount) %>% select(all_of(common_cols)), by = "id")
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
common_cols <- intersect(names(grid5km_sf), names(df_gapCount))
common_cols <- setdiff(common_cols, "id")
df_gapCount_with0 <- as.data.frame(grid5km_sf) %>%
left_join(as.data.frame(df_gapCount) %>% select(all_of(common_cols)), by = "id")
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id")
names(df_gapCount_with0)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id") %>%
select(-c(id, occCount, center_x.x, center_y.x, landType.x, geometry.x))
df_gapCount_with0
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id") %>%
select(c(id, occCount, center_x.x, center_y.x, landType.x, geometry.x))
df_gapCount_with0
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id") %>%
select(c(id, occCount, center_x.x, center_y.x, landType.x, geometry.x)) %>%
mutate(occCount = replace_na(occCount, 0))
df_gapCount_with0
dim(df_gapCount_with0)
names(df_gapCount_with0)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id") %>%
select(c(id, occCount, center_x.x, center_y.x, landType.x, geometry.x)) %>%
mutate(occCount = replace_na(occCount, 0)) %>%
rename_with(~str_remove(., "\\.x$"), ends_with(".x"))
df_gapCount_with0
df_gapCount <- st_read("www/data/processed/df_map.shp")
summary(df_gapCount$occCount)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id") %>%
select(c(id, occCount, center_x.x, center_y.x, landType.x, geometry.x)) %>%
rename_with(~str_remove(., "\\.x$"), ends_with(".x")) %>%
mutate(occCount = replace_na(occCount, 0))
# calculate gap level mean
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp")
number_of_grids_5km <- nrow(grid5km_sf)
sum(df_gapCount_with0$occCount) / number_of_grids_5km
df_gapCount <- st_read("www/data/processed/df_map.shp")
summary(df_gapCount$occCount)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id") %>%
select(c(id, occCount, center_x.x, center_y.x, landType.x, geometry.x)) %>%
rename_with(~str_remove(., "\\.x$"), ends_with(".x")) %>%
mutate(occCount = replace_na(occCount, 0))
# calculate gap level mean
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp")
number_of_grids_5km <- nrow(grid5km_sf)
sum(df_gapCount_with0$occCount) / number_of_grids_5km # 3392.8
## use 3,000 as average for gap level
## i.e. each grid has to contain at least 3,000 records to be considered as non-priority
df_gapCount_with0 <- df_gapCount_with0 %>%
mutate(priority = case_when(occCount < 1000 ~ "建議優先填補",
occCount >= 1000 & occCount < 3000 ~ "建議填補",
occCount >= 3000 ~ "資料筆數高於平均值"))
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_table.shp",
row.names = F, quote = T, append = FALSE)
# save as table
df_gapCount_table <- as.data.frame(df_gapCount_with0) %>%
group_by(priority) %>%
summarise(totalOccCount = sum(occCount))
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_table.shp",
row.names = F, quote = T, append = FALSE, layer_options = "ENCODING=UTF-8")
# save as table
df_gapCount_table <- as.data.frame(df_gapCount_with0) %>%
group_by(priority) %>%
summarise(totalOccCount = sum(occCount))
fwrite(df_gapCount_table, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
df_gapCount_table
df_gapCount_with0
table(df_gapCount_with0$priority)
table(df_gapCount_with0$priority) %>% sum()
runApp()
df_gapCount_with0
# save as table
df_gapCount_table <- as.data.frame(df_gapCount_with0) %>%
group_by(priority, landType) %>%
summarise(gridCount = n(id))
# save as table
df_gapCount_table <- as.data.frame(df_gapCount_with0) %>%
group_by(priority, landType) %>%
summarise(gridCount = n())
df_gapCount_table
sum(df_gapCount_table$gridCount)
fwrite(df_gapCount_table, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
runApp()
runApp()
runApp()
gapCountdf <- fread("www/data/processed/df_gapCount_table.csv", sep = ",", encoding = "UTF-8")
gapCountdf
gapCountdf_sorted <- gapCountdf[order(factor(gapCountdf$priority, levels = c("建議優先填補", "建議填補", "資料筆數高於平均值"))), ]
gapCountdf_sorted
gapCountdf_sorted <- gapCountdf_sorted %>%
rename("priority" = "優先填補等級", "landType" = "地型分類", "gridCount" = "網格數")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
as.data.frame(df_gapCount_with0)
# make CSV gap table for download
df_gapCount_table_csv <- as.data.frame(df_gapCount_with0) %>%
select(-geometry) %>%
filter(landType != "海洋") %>%
select(-landType) %>%
group_by(id, priority) %>%
summarise(occCount = sum(occCount)) %>%
ungroup()
df_gapCount_with0
# make CSV gap table for download
fwrite(df_gapCount_with0, "www/data/processed/df_gapCount_with0.csv",
row.names = F, quote = T)
# make CSV gap table for download
fwrite(as.data.frame(df_gapCount_with0), "www/data/processed/df_gapCount_with0.csv",
row.names = F, quote = T)
as.data.frame(df_gapCount_with0)
# make CSV gap table for download
fwrite(as.data.frame(df_gapCount_with0), "www/data/processed/df_gapCount_with0.csv",
row.names = F, quote = T)
is.data.frame(df_gapCount_with0)
# make CSV gap table for download
# Convert sf object to data frame and extract geometry as WKT
df_gapCount_with0_df <- st_drop_geometry(df_gapCount_with0)
df_gapCount_with0_df$geometry <- st_as_text(st_geometry(df_gapCount_with0))
# make CSV gap table for download
# Convert sf object to data frame and extract geometry as WKT
df_gapCount_with0_df <- st_drop_geometry(df_gapCount_with0)
df_gapCount_with0_df$geometry <- st_as_text(st_geometry(df_gapCount_with0_df))
# make CSV gap table for download
# Extract geometry as WKT first
geometry_wkt <- st_as_text(st_geometry(df_gapCount_with0))
# make CSV gap table for download
# Extract geometry as WKT first
geometry_wkt <- st_as_text(st_geometry(df_gapCount_with0))
df_gapCount <- st_read("www/data/processed/df_map.shp")
summary(df_gapCount$occCount)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id") %>%
select(c(id, occCount, center_x.x, center_y.x, landType.x, geometry.x)) %>%
rename_with(~str_remove(., "\\.x$"), ends_with(".x")) %>%
mutate(occCount = replace_na(occCount, 0))
# calculate gap level mean
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp")
number_of_grids_5km <- nrow(grid5km_sf)
sum(df_gapCount_with0$occCount) / number_of_grids_5km # 3392.8
## use 3,000 as average for gap level
## i.e. each grid has to contain at least 3,000 records to be considered as non-priority
df_gapCount_with0 <- df_gapCount_with0 %>%
mutate(priority = case_when(occCount < 1000 ~ "建議優先填補",
occCount >= 1000 & occCount < 3000 ~ "建議填補",
occCount >= 3000 ~ "資料筆數高於平均值"))
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_table.shp",
row.names = F, quote = T, append = FALSE, layer_options = "ENCODING=UTF-8")
# save as table
df_gapCount_table <- as.data.frame(df_gapCount_with0) %>%
group_by(priority, landType) %>%
summarise(gridCount = n())
fwrite(df_gapCount_table, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
# make CSV gap table for download
# Extract geometry as WKT first
geometry_wkt <- st_as_text(st_geometry(df_gapCount_with0))
fwrite(df_gapCount_with0, "www/data/processed/df_gapCount_with0.csv",
row.names = FALSE, quote = TRUE)
# make CSV gap table for download
write.csv(df_gapCount_with0, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
df_gapCount <- st_read("www/data/processed/df_map.shp")
summary(df_gapCount$occCount)
## df_gapCount contains only grid with at least 1 occCount, merge with grid5km_sf to get all grid (include those with 0 occCount)
df_gapCount_with0 <- left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id") %>%
select(c(id, occCount, center_x.x, center_y.x, landType.x, geometry.x)) %>%
rename_with(~str_remove(., "\\.x$"), ends_with(".x")) %>%
mutate(occCount = replace_na(occCount, 0))
# calculate gap level mean
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/TWshp_grid5km_landType.shp")
number_of_grids_5km <- nrow(grid5km_sf)
sum(df_gapCount_with0$occCount) / number_of_grids_5km # 3392.8
## use 3,000 as average for gap level
## i.e. each grid has to contain at least 3,000 records to be considered as non-priority
df_gapCount_with0 <- df_gapCount_with0 %>%
mutate(priority = case_when(occCount < 1000 ~ "建議優先填補",
occCount >= 1000 & occCount < 3000 ~ "建議填補",
occCount >= 3000 ~ "資料筆數高於平均值"))
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_table.shp",
row.names = F, quote = T, append = FALSE, layer_options = "ENCODING=UTF-8")
# save as table
df_gapCount_table <- as.data.frame(df_gapCount_with0) %>%
group_by(priority, landType) %>%
summarise(gridCount = n())
fwrite(df_gapCount_table, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
# make CSV gap table for download
write.csv(df_gapCount_with0, "www/data/processed/df_gapCount_with0.csv",
row.names = F, quote = T)
df_gapCount_with0
left_join(as.data.frame(grid5km_sf), as.data.frame(df_gapCount), by = "id")
df_gapCount_with0
# save for Google My Map
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_table.kmz",
driver = "LIBKML",
layer_options = c("ENCODING=UTF-8", "WRITE_BBOX=YES"),
delete_dsn = TRUE)
# save for Google My Map
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_table.kml",
driver = "KML",
layer_options = "ENCODING=UTF-8",
delete_dsn = TRUE)
# save for Google My Map
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_with0_Google.kml",
driver = "KML",
layer_options = "ENCODING=UTF-8",
delete_dsn = TRUE)
# save for Google My Map
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_with0_Google.kml",
driver = "KML",
layer_options = "ENCODING=UTF-8",
delete_dsn = TRUE)
# save for Google My Map
st_write(df_gapCount_with0, "www/data/processed/df_gapCount_with0_Google.kml",
driver = "KML",
#layer_options = "ENCODING=UTF-8",
delete_dsn = TRUE)
# save for Google My Map
combined_geometry <- st_union(df_gapCount_with0)
df_gapCount_with0
# save for Google My Map
df_gapCount_with0_sf <- st_as_sf(df_gapCount_with0, wkt = "geometry", crs = 4326)
# Preparation for Google My Map
df_gapCount_with0
# Preparation for Google My Map
df <- df_gapCount_with0
# Create a list of data frames, split by priority and landType
split_dfs <- split(df, list(df$priority, df$landType))
split_dfs
names(split_dfs)
summary(split_dfs)
for (name in names(split_dfs)) {
cat("Dimensions of", name, ":", dim(split_dfs[[name]]), "\n")
}
df <- df_gapCount_with0
## create a list of data frames, split by priority and landType
split_dfs <- split(df, list(df$priority, df$landType))
## check their dim() as Google My Map only supports 2000 rows
for (name in names(split_dfs)) {
cat("Dimensions of", name, ":", dim(split_dfs[[name]]), "\n")
}
split_large_df <- function(df, max_rows = 2000) {
if (nrow(df) <= max_rows) {
return(list(df))
} else {
part1 <- df %>% slice(1:max_rows)
part2 <- df %>% slice((max_rows + 1):n())
return(list(part1 = part1, part2 = part2))
}
}
# Apply the function to each dataframe in split_dfs
split_dfs_adjusted <- lapply(names(split_dfs), function(name) {
df <- split_dfs[[name]]
split_result <- split_large_df(df)
if (length(split_result) == 1) {
return(setNames(split_result, name))
} else {
return(setNames(split_result, paste0(name, c("_part1", "_part2"))))
}
})
# Flatten the list
split_dfs_final <- unlist(split_dfs_adjusted, recursive = FALSE)
cat("Dimensions of", name, ":", dim(split_dfs_final[[name]]), "\n")
for (name in names(split_dfs_final)) {
cat("Dimensions of", name, ":", dim(split_dfs_final[[name]]), "\n")
}
###
for (name in names(split_dfs_final)) {
# Check if the data frame is already an sf object
if (!inherits(split_dfs_final[[name]], "sf")) {
# If it's not an sf object but has a geometry column, convert it
if ("geometry" %in% colnames(split_dfs_final[[name]])) {
split_dfs_final[[name]] <- st_as_sf(split_dfs_final[[name]])
} else {
# If there's no geometry column, skip this data frame or handle the error
warning(paste("Skipping", name, "- no geometry column found"))
next
}
}
# Write to KML
st_write(split_dfs[[name]],
dsn = paste0("www/data/processed/GoogleMyMap/gmm_", name, ".kml"),
driver = "KML",
delete_dsn = TRUE)
}
###
for (name in names(split_dfs_final)) {
# Check if the data frame is already an sf object
if (!inherits(split_dfs_final[[name]], "sf")) {
# If it's not an sf object but has a geometry column, convert it
if ("geometry" %in% colnames(split_dfs_final[[name]])) {
split_dfs_final[[name]] <- st_as_sf(split_dfs_final[[name]])
} else {
# If there's no geometry column, skip this data frame or handle the error
warning(paste("Skipping", name, "- no geometry column found"))
next
}
}
# Write to KML
st_write(split_dfs_final[[name]],
dsn = paste0("www/data/processed/GoogleMyMap/gmm_", name, ".kml"),
driver = "KML",
delete_dsn = TRUE)
}
runApp()
runApp()
runApp()
