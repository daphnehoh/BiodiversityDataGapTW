## gapMap
## grid layer
occ.grid5km_sf <- st_read("www/data/layers/5km/0_05degree_tw_landocean_grid.shp")
library(shiny)
library(tidyverse)
library(leaflet)
library(leaflet.providers)
library(leaflet.extras)
library(rvest)
library(DT)
library(sp)
library(sf)
library(data.table)
library(plotly)
runApp()
df_spatial_allOccCount_grid_table <- fread("www/data/processed/df_spatial_allOccCount_grid_table.csv",
sep = ",", encoding = "UTF-8")
df_spatial_allOccCount_grid_table
runApp()
# Load map data
df_map <- st_read("www/data/processed/df_map.shp")
df_map
pal_map <- colorNumeric(palette = "YlOrRd", domain = df_map$occCount)
pal_map
df_map$occCount
pal_map <- colorNumeric(palette = "YlOrRd", domain = df_map$occCount)
pal_map
str(df_map$occCount)
summary(df_map$occCount)
summary(df_map_taxa$occCount)
df_taxa_map <- st_read("www/data/processed/df_taxa_map.shp")
df_taxa_map <- st_read("www/data/processed/df_taxa_map.shp")
summary(df_map_taxa$occCount)
summary(df_taxa_map$occCount)
summary(df_map$occCount)
runApp()
runApp()
runApp()
runApp()
# save as shp file
df_gapCount <- st_read("www/data/processed/df_map.shp")
df_gapCount
summary(df_gapCount$occCount)
grid5km_sf <- st_read("www/data/layers/5km/0_05degree_tw_landocean_grid.shp")
grid5km_sf
number_of_grids_5km <- nrow(grid5km_sf)
number_of_grids_5km
df_gapCount
sum(df_gapCount$occCount)
runApp()
number_of_grids_5km <- nrow(grid5km_sf)
sum(df_gapCount$occCount) / number_of_grids_5km #
df_gapCount <- df_gapCount %>%
mutate(priority = case_when(occCount < 1000 ~ "建議優先填補網格數",
occCount >= 1000 & occCount < 4500 ~ "建議填補網格數",
occCount >= 4500 ~ "資料筆數高於平均值網格數"))
df_gapCount
table(df_gapCount$priority)
grid5km_sf
df_gapCount
tbia <- fread("www/data/processed/tbia_habitat.csv",
sep = ",", colClasses = "character", encoding = "UTF-8", na.strings = c("", "NA", "N/A"))
head(tbia)
df_taxa_map
df_gapCount <- st_read("www/data/processed/df_map.shp")
summary(df_gapCount$occCount)
grid5km_sf <- st_read("www/data/layers/5km/0_05degree_tw_landocean_grid.shp")
number_of_grids_5km <- nrow(grid5km_sf)
sum(df_gapCount$occCount) / number_of_grids_5km # 4653.9
## use 4,500 as average for gap level
## i.e. each grid has to contain at least 4,500 records to be considered as non-priority
df_gapCount <- df_gapCount %>%
mutate(priority = case_when(occCount < 1000 ~ "建議優先填補網格數",
occCount >= 1000 & occCount < 4500 ~ "建議填補網格數",
occCount >= 4500 ~ "資料筆數高於平均值網格數"))
st_write(df_gapCount, "www/data/processed/df_gapCount_table.shp",
row.names = F, quote = T, append = FALSE)
# save as table
df_gapCount_table <- as.data.frame(df_gapCount) %>%
group_by(priority) %>%
summarise(gridCount = sum(occCount))
fwrite(df_gapCount_table, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
runApp()
df_gapCount
df_gapCount_table
# save as table
df_gapCount_table <- as.data.frame(df_gapCount) %>%
group_by(priority) %>%
summarise(totalOccCount = sum(occCount))
fwrite(df_gapCount_table, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
df_gapCount_table
df_gapCount <- df_gapCount %>%
mutate(priority = case_when(occCount < 1000 ~ "建議優先填補",
occCount >= 1000 & occCount < 4500 ~ "建議填補",
occCount >= 4500 ~ "資料筆數高於平均值"))
st_write(df_gapCount, "www/data/processed/df_gapCount_table.shp",
row.names = F, quote = T, append = FALSE)
# save as table
df_gapCount_table <- as.data.frame(df_gapCount) %>%
group_by(priority) %>%
summarise(totalOccCount = sum(occCount))
fwrite(df_gapCount_table, "www/data/processed/df_gapCount_table.csv",
row.names = F, quote = T)
df_gapCount_table
sum(df_gapCount_table$totalOccCount)
occ.grid5km
## gapMap
## grid layer
occ.grid5km_sf <- st_read("www/data/layers/5km/0_05degree_tw_landocean_grid.shp")
occ.grid5km_sf
df_gapCount
runApp()
df_gapCount_table_shp
df_gapCount_table_shp <- st_read("www/data/processed/df_gapCount_table.shp")
df_gapCount_table_shp
summary(df_gapCount_table_shp$occCount)
runApp()
runApp()
runApp()
runApp()
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/output_from_QGIS_TWshp/TWshp_grid5km.shp")
tw_sf <- st_read("www/data/layers/TWshp_land&sea/TWshp_land&sea.shp")
tw_sf
grid5km_sf
table(grid5km_sf$type)
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/output_from_QGIS_TWshp/TWshp_grid5km.shp") %>%
select(id, center_x, center_y, geometry)
grid5km_sf
tw_sf
# load taiwan area polygon
tw_sf <- st_read("www/data/layers/TWshp_land&sea/TWshp_land&sea.shp") %>%
select(TOWNID, geometry)
tw_sf
# intersect layers
grid5km_tw_sf <- st_join(grid5km_sf, tw_sf, join = st_intersects, left = TRUE, largest = TRUE)
# intersect layers
## Check validity of grid5km_sf
invalid_grid5km <- st_is_valid(grid5km_sf, reason = TRUE)
invalid_grid5km
invalid_grid5km[invalid_grid5km != "Valid"]
print(invalid_grid5km[invalid_grid5km != "Valid"])
invalid_grid5km
# intersect layers
# Fix invalid geometries
grid5km_sf <- st_make_valid(grid5km_sf)
tw_sf <- st_make_valid(tw_sf)
# intersect
grid5km_tw_sf <- st_join(grid5km_sf, tw_sf, join = st_intersects, left = TRUE, largest = TRUE)
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/output_from_QGIS_TWshp/TWshp_grid5km.shp") %>%
select(id, center_x, center_y, geometry)
# load taiwan area polygon
tw_sf <- st_read("www/data/layers/TWshp_land&sea/TWshp_land&sea.shp") %>%
select(TOWNID, geometry)
# intersect layers
# Fix invalid geometries
grid5km_sf <- st_make_valid(st_simplify(grid5km_sf, dTolerance = 0.01))
tw_sf <- st_make_valid(st_simplify(tw_sf, dTolerance = 0.01))
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/output_from_QGIS_TWshp/TWshp_grid5km.shp") %>%
select(id, center_x, center_y, geometry)
# load taiwan area polygon
tw_sf <- st_read("www/data/layers/TWshp_land&sea/TWshp_land&sea.shp") %>%
select(TOWNID, geometry)
# intersect layers
# Simplify and fix invalid geometries
grid5km_sf <- st_make_valid(st_simplify(grid5km_sf, dTolerance = 0.01))
tw_sf <- st_make_valid(st_simplify(tw_sf, dTolerance = 0.01))
tw_sf <- st_make_valid(st_simplify(tw_sf, dTolerance = 0.01))
tw_sf <- st_buffer(tw_sf, 0) %>% st_make_valid()
gc()
tbia <- fread("C:/Users/taibi/Documents/GitHub/TBIA-data-review/02.processed_data/ver5_ver20240704_shiny/tbia5_vtaxa.csv",
sep = ",", colClasses = "character", encoding = "UTF-8", na.strings = c("", "NA", "N/A"))
setwd("C:/Users/taibi/Documents/GitHub/BiodiversityDataGapTW/shinyapp-zh/")
.packs <- c("httr", "jsonlite", "data.table",
"dplyr", "stringr", "tidyverse",
"sf", "parallel", "lwgeom")
sapply(.packs, require, character.only = TRUE)
tbia <- fread("www/data/processed/tbia_habitat.csv",
sep = ",", colClasses = "character", encoding = "UTF-8", na.strings = c("", "NA", "N/A"))
taicol <- fread("www/data/processed/TaiCOL_taxon_20240621_taxaSubGroup.csv",
sep = ",", colClasses = "character", encoding = "UTF-8", na.strings = c("", "NA", "N/A"))
grid5km_sf <- st_read("www/data/layers/TWshp_land&sea_grids/output_from_QGIS_TWshp/TWshp_grid5km.shp")
# load the tbia table
df_map <- tbia[, c("id", "longitude", "latitude", "coordinatePrecision", "coordinateUncertaintyInMeters", "taxaSubGroup")] %>%
mutate(longitude = as.numeric(longitude), latitude = as.numeric(latitude),
coordinatePrecision = as.numeric(coordinatePrecision),
coordinateUncertaintyInMeters = as.numeric(coordinateUncertaintyInMeters))
## 1. exclude uncertainty in distance
table(df_map$coordinatePrecision)
table(df_map$coordinateUncertaintyInMeters)
df_map <- df_map[df_map$coordinateUncertaintyInMeters < 5000 | is.na(df_map$coordinateUncertaintyInMeters)] # exclude < 5km (5000 meter) for 5km grid plotting, 1,180,542 excluded
## 2. map All records to grid
df_map_stats <- df_map %>%
group_by(taxaSubGroup, latitude, longitude) %>%
count()
# separate to group for parallel processing
n <- 200000
num_groups <- ceiling(nrow(df_map_stats) / n)
records_in_last_group <- nrow(df_map_stats) %% n
group_var <- rep(1:num_groups, each = n)
group_var <- c(group_var, rep(num_groups + 1, times = records_in_last_group))
df_map_stats_groupList <- split(df_map_stats, group_var)
catchLocation <- function(x){
x %>%
st_as_sf(coords = c("longitude", "latitude"), remove = FALSE) %>% # set coordinates
st_set_crs(4326) %>%  # table transform to polygon
st_join(., dg_grid, join = st_intersects, left = TRUE, largest = TRUE) %>%
st_drop_geometry(.)
}
#### parallel ####
cpu.cores <- detectCores() - 8
cl <- makeCluster(cpu.cores)
clusterEvalQ(cl, { # make sure all clusters are ready
library(tidyverse)
library(data.table)
library(sf)
library(lwgeom)
dg_grid <- st_read("www/data/layers/TWshp_land&sea_grids/output_from_QGIS_TWshp/TWshp_grid5km.shp")
dg_grid <- as(dg_grid, "sf")%>%
st_set_crs(4326)
sf_use_s2(F)
}
)
system.time(
df_map_grid <- parLapply(cl, df_map_stats_groupList, catchLocation)%>%
do.call(rbind,.))
stopCluster(cl)
df_map_grid
shiny::runApp()
